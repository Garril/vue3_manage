# vue3_manage



<hr/>

## store

封装后，使用方式如下（只展示相关部分）：

```ts
import { createApp } from 'vue'
import store from './store'
import { setupStore } from './store'

const app = createApp(App)
app.use(store)
setupStore()
```

### 目录结构

```ts
store
    login
        login.ts
        types.ts
    main
        analysis
              dashboard.ts
              types.ts
        system
              system.ts
              types.ts
index.ts
types.ts
```

### base config

```ts
// store/index.ts
import { createStore, Store, useStore as useVuexStore } from 'vuex'
import { IRootState } from './types'

const store = createStore<IRootState>({
  state() {
    return {
      name: 'garril',
      age: 18,      
    }
  },
	// mutation 有必须同步执行的限制，
  // 而 Action 不受约束，可以在 action 内部执行异步操作  
  mutations: {
    changeName(state, newName) {
      state.name = newName
    },
  },
  getters: {},
  // Action 通常是异步的，如何知道 action 什么时候结束？如何才能组合多个 action，处理复杂的异步流程
  // store.dispatch 可以处理被触发的 action 的处理函数返回 Promise，并且 store.dispatch 仍旧返回 Promise
  actions: {
    async getInitialDataAction({ commit }) {
      // 1.请求xxx数据
      const requestRes = await getxxxData('/xxx', {
        offset: 0,
        size: 100
      })
      const { list: name } = requestRes.data
      // 2.保存数据
      commit('changeName', name)
    }
  },
  modules: {}
})
/*
	为什么要（改写useStore）把vuex中的useStore函数另名为 useVuexStore, 并return？
	因为如果我们
	import { useStore } from 'vuex'
	然后直接用这个useStore，会很麻烦，因为这个	useStore 
	如果 在一个setup下使用还好，但是在setup的子函数中使用，就变成undefined了
	它只能在setup函数中调用（如果还是不行，重新install，再看看版本）
*/
export function useStore(): Store<IStoreType> {
  return useVuexStore()
}

// store/types.ts
export interface IRootState {
  name: string
  age: number
}
```

### actual use

#### 类型定义

```ts
import { ILoginState } from './login/types'
import { ISystemState } from './main/system/types'
import { IDashboardState } from './main/analysis/types'

export interface IRootState {
  name: string
  age: number
  entireDepartment: any[]
  entireRole: any[]
  entireMenu: any[]
}

export interface IRootWithModule {
  login: ILoginState
  system: ISystemState
  dashboard: IDashboardState
}

export type IStoreType = IRootState & IRootWithModule
```

#### index.ts

```ts
// store/index.ts
import { createStore, Store, useStore as useVuexStore } from 'vuex'

import login from './login/login'
import system from './main/system/system'
import dashboard from './main/analysis/dashboard'

import { getPageListData } from '@/service/main/system/system'

import { IRootState, IStoreType } from './types'

const store = createStore<IRootState>({
  state() {
    return {
      name: 'garril',
      age: 18,
      entireDepartment: [],
      entireRole: [],
      entireMenu: []
    }
  },
  mutations: {
    changeEntireDepartment(state, list) {
      state.entireDepartment = list
    },
    changeEntireRole(state, list) {
      state.entireRole = list
    },
    changeEntireMenu(state, list) {
      state.entireMenu = list
    }
  },
  getters: {},
  actions: {
    async getInitialDataAction({ commit }) {
      // 1.请求部门和角色数据
      const departmentResult = await getPageListData('/department/list', {
        offset: 0,
        size: 1000
      })
      const { list: departmentList } = departmentResult.data
      const roleResult = await getPageListData('/role/list', {
        offset: 0,
        size: 1000
      })
      const { list: roleList } = roleResult.data
      const menuResult = await getPageListData('/menu/list', {})
      const { list: menuList } = menuResult.data

      // 2.保存数据
      commit('changeEntireDepartment', departmentList)
      commit('changeEntireRole', roleList)
      commit('changeEntireMenu', menuList)
    }
  },
  modules: {
    login,
    system,
    dashboard
  }
})
// setupStore在项目main.ts被调用，初始化操作，在login的store中，先进行token检查
// token合格，dispatch调这里的getInitialDataAction，进行各种数据的重新请求和更新
export function setupStore() {
  store.dispatch('login/loadLocalLogin')
  // store.dispatch('getInitialDataAction') --- 缺少token检查和基础信息保存到localStorage的过程
}

// IStoreType看类型定义---> IRootState & IRootWithModule
// ( IRootWithModule: 相当于各个模块State的&)
export function useStore(): Store<IStoreType> {
  return useVuexStore()
}

export default store
```

除了`login`其他模块的 `store`略，结构差不多

#### login / types.ts

```ts
// store/login/types.ts
export interface ILoginState {
  token: string
  userInfo: any
  userMenus: any
  permissions: string[]
}
```

#### login / login.ts

```ts
// store/login/login.ts

// store
import { Module } from 'vuex'

// service
import {
  accountLoginRequest,
  requestUserInfoById,
  requestUserMenusByRoleId
} from '@/service/login/login'

// utils/router
import localCache from '@/utils/cache'
// mapMenusToRoutes 拿到自己的权限routes列表
import { mapMenusToRoutes, mapMenusToPermissions } from '@/utils/map-menus'
import router from '@/router'

// types
import { IAccount } from '@/service/login/type'
import { ILoginState } from './types'
import { IRootState } from '../types'

const loginModule: Module<ILoginState, IRootState> = {
  namespaced: true,
  state() {
    return {
      token: '',
      userInfo: {},
      userMenus: [],
      permissions: []
    }
  },
  getters: {},
  mutations: {
    changeToken(state, token: string) {
      state.token = token
    },
    changeUserInfo(state, userInfo: any) {
      state.userInfo = userInfo
    },
    changeUserMenus(state, userMenus: any) {
      state.userMenus = userMenus

      console.log('注册动态路由')

      // 拿到自己的权限表单
      const routes = mapMenusToRoutes(userMenus)
      // 遍历routes，将router
      routes.forEach((route) => {
        router.addRoute('main', route)
      })
      // 获取用户按钮的权限
      const permissions = mapMenusToPermissions(userMenus)
      state.permissions = permissions
    }
  },
  actions: {
    async accountLoginAction({ commit, dispatch }, payload: IAccount) {
      // 1.实现登录逻辑
      const loginResult = await accountLoginRequest(payload)
      const { id, token } = loginResult.data
      commit('changeToken', token)
      localCache.setCache('token', token)
      // 发送初始化的请求(完整的role/department)
      dispatch('getInitialDataAction', null, { root: true })

      // 2.请求用户信息
      const userInfoResult = await requestUserInfoById(id)
      const userInfo = userInfoResult.data
      commit('changeUserInfo', userInfo)
      localCache.setCache('userInfo', userInfo)

      // 3.请求用户菜单
      const userMenusResult = await requestUserMenusByRoleId(userInfo.role.id)
      const userMenus = userMenusResult.data
      commit('changeUserMenus', userMenus)
      localCache.setCache('userMenus', userMenus)

      // 4.跳到首页
      router.push('/main')
    },
    loadLocalLogin({ commit, dispatch }) {
      const token = localCache.getCache('token')
      if (token) {
        commit('changeToken', token)
        // 发送初始化的请求(完整的role/department)
        dispatch('getInitialDataAction', null, { root: true })
      } else {
        localCache.deleteCache('token')
      }
      const userInfo = localCache.getCache('userInfo')
      if (userInfo) {
        commit('changeUserInfo', userInfo)
      }
      const userMenus = localCache.getCache('userMenus')
      if (userMenus) {
        commit('changeUserMenus', userMenus)
      }
    }
    
  }
}

export default loginModule

```

#### mapMenusToPermissions

```ts
// 获取用户按钮的权限
export function mapMenusToPermissions(userMenus: any[]) {
  const permissions: string[] = []
  
  const _recurseGetPermission = (menus: any[]) => {
    for (const menu of menus) {
      if (menu.type === 1 || menu.type === 2) {
        // console.log('menu--1', menu)
        _recurseGetPermission(menu.children ?? [])
      } else if (menu.type === 3) {
        // console.log('menu--2', menu)
        // console.log('menu.permission', menu.perssion)
        permissions.push(menu.permission)
        // menu.permission 类似于:  "system:users:create"
      }
    }
  }
  _recurseGetPermission(userMenus)

  return permissions
}
```

![image-20230308204317790](https://forupload.oss-cn-guangzhou.aliyuncs.com/newImg/image-20230308204317790.png)

#### in cpns

```ts
import { defineComponent, computed } from 'vue'
import { useStore } from '@/store'

export default defineComponent({
  setup() {
    const store = useStore()
    store.dispatch('xx_module/yyy_Action')
    const testData = computed(() => {
      const aaa_data = store.state.yyy_module.aaa_data
      const ccc_data = store.state.xxx_module.ccc_data
      return { aaa_data, ccc_data }
    })
  }
})
```



<hr/>

## axios

1、定义Request类，含有instance，interceptors，showLoading，loading

### define

#### class Request

```ts
class GRequest {
  instance: AxiosInstance
  interceptors?: GInterceptors
  showLoading: boolean
  loading?: ILoadingInstance
}
```

#### constructor参数类型

```ts
import type { AxiosRequestConfig, AxiosResponse } from 'axios'

export interface GInterceptors<T = AxiosResponse> {
  requestInterceptor?: (config: AxiosRequestConfig) => AxiosRequestConfig
  requestInterceptorCatch?: (error: any) => any
  // GRequestConfig搞个泛型，就是为了responseInterceptor，响应拦截return类型无误
  responseInterceptor?: (res: T) => T
  responseInterceptorCatch?: (error: any) => any
}

export interface GRequestConfig<T = AxiosResponse> extends AxiosRequestConfig {
  interceptors?: GInterceptors<T>
  showLoading?: boolean
}
// 可以看出，我们需要一个interceptors，包含4个拦截回调函数 以及 showLoading
```

#### constructor

```ts
constructor(config: GRequestConfig) {
  // 创建axios实例
  this.instance = axios.create(config)

  // 保存基本信息
  this.showLoading = config.showLoading ?? DEAFULT_LOADING
  this.interceptors = config.interceptors

  // 使用拦截器
  // 1.从config中取出的拦截器是对应的实例的拦截器（new Request传入）
  this.instance.interceptors.request.use(
    this.interceptors?.requestInterceptor,
    this.interceptors?.requestInterceptorCatch
  )
  this.instance.interceptors.response.use(
    this.interceptors?.responseInterceptor,
    this.interceptors?.responseInterceptorCatch
  )

  // 2.添加所有的实例都有的拦截器（类实例一定有的，写死的）
  this.instance.interceptors.request.use(
    (config) => {
      if (this.showLoading) {
        this.loading = ElLoading.service({
          lock: true,
          text: '正在请求数据....',
          background: 'rgba(0, 0, 0, 0.5)'
        })
      }
      return config
    },
    (err) => {
      return err
    }
  )

  this.instance.interceptors.response.use(
    (res) => {
      // 将loading移除
      this.loading?.close()

      const data = res.data
      if (data.returnCode === '-1001') {
        console.log('请求失败~, 错误信息')
      } else {
        return data
      }
    },
    (err) => {
      // 将loading移除
      this.loading?.close()

      // 例子: 判断不同的HttpErrorCode显示不同的错误信息
      if (err.response.status === 404) {
        console.log('404的错误~')
      }
      return err
    }
  )
}
```

#### request

```ts
// request方法 return一个promise
// 每次request传入的config，其实还是GRequestConfig，有interceptors参数
// 允许传入拦截器，对每个请求，做不一样的拦截回调
request<T = any>(config: GRequestConfig<T>): Promise<T> {
  return new Promise((resolve, reject) => {
    // 1.单个请求对请求config的处理
    if (config.interceptors?.requestInterceptor) {
      config = config.interceptors.requestInterceptor(config) // 拦截器需要return config
    }

    // 2.判断是否需要显示loading
    if (config.showLoading === false) {
      this.showLoading = config.showLoading
    }

    this.instance
      .request<any, T>(config)
      .then((res) => {
      // 1.单个请求对数据的处理
      if (config.interceptors?.responseInterceptor) {
        res = config.interceptors.responseInterceptor(res)
      }
      // 2.将showLoading设置true, 这样不会影响下一个请求
      this.showLoading = DEAFULT_LOADING

      // 3.将结果resolve返回出去
      resolve(res)
    })
      .catch((err) => {
      // 将showLoading设置true, 这样不会影响下一个请求
      this.showLoading = DEAFULT_LOADING
      reject(err)
      return err
    })
  })
}
```



#### get\post...

```ts
get<T = any>(config: GRequestConfig<T>): Promise<T> {
  return this.request<T>({ ...config, method: 'GET' })
}

post<T = any>(config: GRequestConfig<T>): Promise<T> {
  return this.request<T>({ ...config, method: 'POST' })
}

delete<T = any>(config: GRequestConfig<T>): Promise<T> {
  return this.request<T>({ ...config, method: 'DELETE' })
}

patch<T = any>(config: GRequestConfig<T>): Promise<T> {
  return this.request<T>({ ...config, method: 'PATCH' })
}
```

#### config

```ts
// 开发环境: development
// 生成环境: production
// 测试环境: test
let BASE_URL = ''
const TIME_OUT = 10000

if (process.env.NODE_ENV === 'development') {
  BASE_URL = '/api'
} else if (process.env.NODE_ENV === 'production') {
  BASE_URL = 'http://garril.org/prod'
} else {
  BASE_URL = 'http://garril.org/test'
}

export { BASE_URL, TIME_OUT }
```



### use

#### create instance of Request

```ts
// service统一出口
import GRequest from './request'
import { BASE_URL, TIME_OUT } from './request/config'

import localCache from '@/utils/cache'

const gRequest = new GRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT,
  interceptors: {
    requestInterceptor: (config) => {
      // 携带token的拦截
      const token = localCache.getCache('token')
      if (token) {
        config.headers.Authorization = `Bearer ${token}`
      }
      return config
    },
    requestInterceptorCatch: (err) => {
      return err
    },
    responseInterceptor: (res) => {
      return res
    },
    responseInterceptorCatch: (err) => {
      return err
    }
  }
})

export default gRequest
```

#### get\post...

```ts
// 相关类型定义
export interface IDataType<T = any> {
  code: number
  data: T
}
export interface IAccount {
  name: string
  password: string
}

export interface ILoginResult {
  id: number
  name: string
  token: string
}
```

```ts
import gRequest from '../index'

enum LoginAPI {
  AccountLogin = '/login',
  LoginUserInfo = '/users/', // 用法: /users/1
  UserMenus = '/role/' // 用法: role/1/menu
}

export function accountLoginRequest(account: IAccount) {
  return gRequest.post<IDataType<ILoginResult>>({
    url: LoginAPI.AccountLogin,
    data: account
  })
}

export function requestUserInfoById(id: number) {
  return gRequest.get<IDataType>({
    url: LoginAPI.LoginUserInfo + id,
    showLoading: false
  })
}
```



#### interceptors summary

直到这里，我们可以知道，一共有3中拦截器

第一种：在我们`new Request`的时候传入`config`中，类实例的`interceptors`

这里是对`token`进行判断 和 保存到config中

```ts
const gRequest = new GRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT,
  interceptors: {
    requestInterceptor: (config) => {
      // 携带token的拦截
      const token = localCache.getCache('token')
      if (token) {
        config.headers.Authorization = `Bearer ${token}`
      }
      return config
    },
    requestInterceptorCatch: (err) => {
      return err
    },
    responseInterceptor: (res) => {
      return res
    },
    responseInterceptorCatch: (err) => {
      return err
    }
  }
})
```

第二种：写死在 `Request`类中的，这里实现了 通过传入的`config`中的`showLoading`属性判断是否显示`ElLoading`组件

```ts
this.instance.interceptors.request.use(
  (config) => {
    if (this.showLoading) {
      this.loading = ElLoading.service({
        lock: true,
        text: '正在请求数据....',
        background: 'rgba(0, 0, 0, 0.5)'
      })
    }
    return config
  },
  (err) => {
    return err
  }
)
```

并将其保存到类变量 `this.loading`中，且在写死的 `response`拦截器中`close`

```ts
this.instance.interceptors.response.use(
  (res) => {
    // 将loading移除
    this.loading?.close()

    const data = res.data
    if (data.returnCode === '-1001') {
      console.log('请求失败~, 错误信息')
    } else {
      return data
    }
  },
  (err) => {
    // 将loading移除
    this.loading?.close()

    // 例子: 判断不同的HttpErrorCode显示不同的错误信息
    if (err.response.status === 404) {
      console.log('404的错误~')
    }
    return err
  }
)
```

第三种：在我们使用 `GRequest`类的实例对象，也就是`gRequest`的 HTTP方法（`get\post\delete\patch`）时传入的`config`

```ts
enum LoginAPI {
  AccountLogin = '/login',
  LoginUserInfo = '/users/', // 用法: /users/1
  UserMenus = '/role/' // 用法: role/1/menu
}

export function accountLoginRequest(account: IAccount) {
  return gRequest.post<IDataType<ILoginResult>>({
    url: LoginAPI.AccountLogin,
    data: account
  })
}

export function requestUserInfoById(id: number) {
  return gRequest.get<IDataType>({
    url: LoginAPI.LoginUserInfo + id,
    showLoading: false
  })
}

gRequest.get<IDataType>({ .... })
// 这里表示，我的这个get请求要返回 IDataType类型的结果
// IDataType其实只是一种规范，返回Restuful风格的http请求结果 {  data: ... , code: 200 } 
// 泛型T，是data的类型
```

单纯看运用，我们会发现，这里没有传入 拦截器，但是理论上是可以的

```ts
get<T = any>(config: GRequestConfig<T>): Promise<T> {
  return this.request<T>({ ...config, method: 'GET' })
}
// get等方法接收的参数类型为 GRequestConfig<T>
```

而 `interface GRequestConfig`定义如下：

```ts
export interface GRequestConfig<T = AxiosResponse> extends AxiosRequestConfig {
  interceptors?: GInterceptors<T>
  showLoading?: boolean
}
// extends AxiosRequestConfig 可接收 url\data\params\query....
// 其自己定义有 interceptors 和 showLoading
```

再看看 `get` 调用的 `this.request<T>`

```ts
request<T = any>(config: GRequestConfig<T>): Promise<T> {
  return new Promise((resolve, reject) => {
    // 1.单个请求对请求config的处理
    if (config.interceptors?.requestInterceptor) {
      config = config.interceptors.requestInterceptor(config) // 拦截器需要return config
    }
    .......
  })
}
```

<hr/>

## utils

### LocalCache

```ts
class LocalCache {
  setCache(key: string, value: any) {
    window.localStorage.setItem(key, JSON.stringify(value))
  }

  getCache(key: string) {
    // obj => string => obj
    const value = window.localStorage.getItem(key)
    if (value) {
      return JSON.parse(value)
    }
  }

  deleteCache(key: string) {
    window.localStorage.removeItem(key)
  }

  clearCache() {
    window.localStorage.clear()
  }
}

export default new LocalCache()
```

### data-format

```ts
import dayjs from 'dayjs'
import utc from 'dayjs/plugin/utc'

dayjs.extend(utc)

const DATE_TIME_FORMAT = 'YYYY-MM-DD HH:mm:ss'

export function formatUtcString(
  utcString: string,
  format: string = DATE_TIME_FORMAT
) {
  return dayjs.utc(utcString).utcOffset(8).format(format)
}
```

<hr/>

## router

### base config

```ts
import { createRouter, createWebHashHistory } from 'vue-router'
import type { RouteRecordRaw } from 'vue-router'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    redirect: '/main'
  },
  {
    path: '/login',
    name: 'login',
    component: () => import('@/views/login/login.vue')
  },
  {
    path: '/main',
    name: 'main',
    component: () => import('@/views/main/main.vue')
    // children: [] -> 根据userMenus来决定 -> children
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'notFound',
    component: () => import('@/views/not-found/not-found.vue')
  }
]

const router = createRouter({
  routes,
  history: createWebHashHistory()
})

// .......

export default router
```

### 导航守卫

```ts
// 进行token的检查
router.beforeEach((to) => {
  if (to.path !== '/login') {
    const token = localCache.getCache('token')
    if (!token) {
      return '/login'
    }
  }
  // console.log(router.getRoutes())
  // console.log(to) // route对象
  if (to.path === '/main') {
    return firstMenu.url // 就是一个类似redirect的功能
  }
})
```

### 目录结构

去了解`firstMenu`之前，我们需要先知道`router`文件的目录结构

```ts
router 
		main
        analysis
              dashboard
              overview
        product
              category
              goods
        story
              chat
              list
        system
              department
              menu
              role
              user
index.ts(上述base config以及导航守卫 均在此文件中)
```

其中每个最内层文件夹，放着的文件均为其同名 `ts`文件，比如

`main/system/user`文件夹，放着` user.ts `文件（其余文件也一样。类推）

```ts
// user.ts
const user = () => import('@/views/main/system/user/user.vue')
export default {
  path: '/main/system/user',
  name: 'user',
  component: user,
  children: []
}
```



### firstMenu（utils)

`firstMenu`是`utils`中导出的对象，初始化

```ts
let firstMenu: any = null
```

只受函数`mapMenusToRoutes`影响，（在`login`模块的`store/mutation`被调用 ---- 请求用户菜单后 / 本地读取到`cache`的菜单后）

其接收的参数`userMenu`结构如下：

![image-20230308135523070](https://forupload.oss-cn-guangzhou.aliyuncs.com/newImg/image-20230308135523070.png)

```ts
import { RouteRecordRaw } from 'vue-router'
/*
  本地是有完整的一套组件的，但是登录到'/main'时，并不是全部都显示，因为用户权限不同
  这里我们可以看到base config里面的routes，可以说核心就 login 和 main，没有其他
  
  那么要如何实现权限控制渲染表单页面？
  首先依据 路径拼接 还有 require.context 拿到本地router/main下所有ts文件
  遍历文件列表，路径拼接，require文件，最后将route.default，也就是
  export default {
    path: '/main/system/user',
    name: 'user',
    component: user,
    children: []
  }
 push到allRoutes数组中，此后，allRoutes就是对照，它拥有最高权限，拥有所有渲染组件和路径等的信息

 之后，我们 通过发送http请求，获取到 用户对应的权限列表userMenu
 遍历userMenu在allRoutes中找到对应的 route信息, push到routes中
 
 最后 return routes
*/
export function mapMenusToRoutes(userMenus: any[]): RouteRecordRaw[] {
  const routes: RouteRecordRaw[] = []

  // 1.先去加载默认所有的routes
  const allRoutes: RouteRecordRaw[] = []
  
  const routeFiles = require.context('../router/main', true, /\.ts/) // true: 深度遍历拿到所有.ts文件
  /*
  	console.log(routeFiles)
  	
    ƒ webpackContext(req) {
      var id = webpackContextResolve(req);
      return __webpack_require__(id);
    }
  */
  routeFiles.keys().forEach((key) => {
    const route = require('../router/main' + key.split('.')[1])
    allRoutes.push(route.default)
  })
  /*
  	console.log('key', key)
  	
    key ./analysis/dashboard/dashboard.ts
    key ./analysis/overview/overview.ts
    key ./product/category/category.ts
    key ./product/goods/goods.ts
    key ./story/chat/chat.ts
    key ./story/list/list.ts
    key ./system/department/department.ts
    key ./system/menu/menu.ts
    key ./system/role/role.ts
    key ./system/user/user.ts
  */
```

![image-20230308141903553](https://forupload.oss-cn-guangzhou.aliyuncs.com/newImg/image-20230308141903553.png)

```ts
	// .... 紧接上面的

	// 2.根据获取到的菜单，获取需要添加的routes
  const _recurseGetRoute = (menus: any[]) => {
    for (const menu of menus) {
      if (menu.type === 2) { // children
        // 这里（匹配并且加入了所有，但是有些用户没有那么多权限, 他的userMenu不是全套的功能
        const route = allRoutes.find((route) => route.path === menu.url)
        if (route) routes.push(route)
        if (!firstMenu) { // 初始化时为null
          firstMenu = menu // 这里对firstMenu进行了赋值，回导航守卫看看（只是个redirect的功能）
        }
      } else {
        _recurseGetRoute(menu.children)
      }
    }
  }

  _recurseGetRoute(userMenus)

  return routes
}
```



<hr/>

## element-plus

要实现的效果。

```ts
import { createApp } from 'vue'
import { globalRegister } from './global'

const app = createApp(App)
// 注册element-plus
app.use(globalRegister)
```

### register-element

```ts
// global/register-element.ts
import { App } from 'vue'
import 'element-plus/lib/theme-chalk/base.css'

import {
  ElButton,
  ElForm,
  ElFormItem
} from 'element-plus'

const components = [
  ElButton,
  ElForm,
  ElFormItem
]
// 需要什么组件就import，再加入components数组

export default function (app: App): void {
  for (const component of components) { // 遍历注册
    app.component(component.name, component)
  }
}
```

### register-properties

```ts
// global/register-properties.ts
import { App } from 'vue'

import { formatUtcString } from '@/utils/date-format'

export default function registerProperties(app: App) {
  app.config.globalProperties.$filters = {
    foo() {
      console.log('foo')
    },
    formatTime(value: string) {
      return formatUtcString(value)
    }
  }
}
```

### index

```ts
// global/index.ts
import { App } from 'vue'
import registerElement from './register-element'
import registerProperties from './register-properties'

export function globalRegister(app: App): void {
  app.use(registerElement)
  app.use(registerProperties)
}
```

### globalProperties

```ts
/*
	类型：[key: string]: any
	默认：undefined
	用法:
		添加一个可以在 应用的任何组件实例中  访问的全局 property。
		组件的 property 在命名冲突具有优先权。
	这可以代替 Vue 2.x Vue.prototype 扩展 */

// 之前(Vue 2.x)
Vue.prototype.$http = () => {}
 
// 之后(Vue 3.x)
const app = Vue.createApp({})
app.config.globalProperties.$http = () => {}
```

#### use-formatTime

```html
<!-- 可运行，但是打开文件，代码显示报错，....xxxx不存在属性 $filters -->
<template #createAt="scope">
  <span>{{ $filters.formatTime(scope.row.createAt) }}</span>
</template>
<template #updateAt="scope">
  <span>{{ $filters.formatTime(scope.row.updateAt) }}</span>
</template>
```

应该改为

```ts
// 当我们想在组件内调用formatTime时需要使用getCurrentInstance()来获取。
import { getCurrentInstance, onMounted } from "vue";
export default {
  setup( ) {
    const { ctx } = getCurrentInstance(); //获取上下文实例，ctx=vue2的this
    onMounted(() => {
      console.log(ctx, "ctx");
      ctx.formatTime();
    });
  },
};
```

#### 注意

```ts
// getCurrentInstance代表上下文，即当前实例。ctx相当于Vue2的this, 
// 但是需要特别注意的是ctx代替this只适用于开发阶段，如果将项目打包放到生产服务器上运行，就会出错
// ctx无法获取路由和全局挂载对象的。此问题的解决方案就是使用proxy替代ctx，代码参考如下。
import { getCurrentInstance } from 'vue'
export default ({
  name: '',
  setup(){
    const { proxy } = getCurrentInstance() // 使用proxy代替ctx，因为ctx只在开发环境有效
    onMounted(() => {
      console.log(proxy, "proxy");
      proxy.formatTime();
    });
  }
})

// 如果抛红 --> 定义了全局方法之后需要扩充类型
declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    $filters: any
  }
}
```

当然，如果可以的话，还是推荐 provide和inject ，而不是全局属性。 原因参考： https://github.com/vuejs/rfcs/pull/117

This is essentially a legacy escape hatch and not for setup function. 

You should just import things directly or use provide/inject in setup functions.

With the global API change there is no once-for-all global configs anymore. 

2.x multi-root-instance apps will have to be updated to configure each root instance individually. 

If all root instances share the same config, then it can be extracted into a shared function.

#### 补充

```js
// vue2插件实现方式
import Toast from './Toast.vue'

const obj = {}

obj.install = function(Vue) { // 默认会把 Vue 作为参数传过来
  // 创建组件构造器  
  const toastContrustor = Vue.extend(Toast)
  // 创建组件对象
  const toast = new toastContrustor()
  // 对象手动挂载
  toast.$mount(document.createElement('div'))

  document.body.appendChild(toast.$el)

  Vue.prototype.$toast = toast; // 这里赋值注意，应该为9行创建的组件,
}

export default obj
```

<hr/>

## 其他

### node-ref

```vue
<el-form label-width="60px" :rules="rules" :model="account" ref="formRef"></el-form>
<script lang="ts">
  import { ElForm } from 'element-plus'
  import { defineComponent } from 'vue'
  export default defineComponent({
    setup() {
      const formRef = ref<InstanceType<typeof ElForm>>()
    }
  })
</script>
```

































